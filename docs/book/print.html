<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Multifaustus Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for Multifaustus, a MultiPaxos implementation in Rust inspired by the &#x27;Paxos Made Moderately Complex&#x27; paper">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Multifaustus Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/erewok/multifaustus" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="multifaustus-implementation"><a class="header" href="#multifaustus-implementation">Multifaustus Implementation</a></h1>
<p>Multifaustus is an implementation of Multipaxos, a distributed consensus algorithm that enables multiple nodes in a distributed system to agree on a sequence of values, even in the presence of failures. This implementation provides a Rust-based MultiPaxos system with three distinct node types working together to achieve consensus.</p>
<h2 id="system-purpose"><a class="header" href="#system-purpose">System Purpose</a></h2>
<p>This implementation serves as a fault-tolerant distributed state machine where:</p>
<ul>
<li>Multiple clients can submit requests concurrently</li>
<li>All replicas maintain identical state through ordered command execution</li>
<li>The system continues operating despite node failures</li>
<li>Consistency is maintained through the Paxos consensus protocol</li>
</ul>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<p>The system consists of three node types:</p>
<p><strong>Replicas</strong> maintain application state and interface with clients. They receive client requests, coordinate with leaders for ordering, and execute commands in the agreed sequence.</p>
<p><strong>Leaders</strong> coordinate the consensus process by proposing commands and managing the two-phase protocol required for agreement among acceptors.</p>
<p><strong>Acceptors</strong> provide fault-tolerant storage for the consensus protocol, maintaining promises and accepted proposals to ensure safety properties.</p>
<h2 id="algorithm-foundation"><a class="header" href="#algorithm-foundation">Algorithm Foundation</a></h2>
<p>This implementation follows the MultiPaxos protocol as described in:</p>
<ul>
<li>"Paxos Made Simple" by Leslie Lamport (2001)</li>
<li>"Paxos Made Moderately Complex" by Robbert van Renesse and Deniz Altınbüken (2015)</li>
</ul>
<p>The implementation uses a sans-IO design where message handling is separated from network transport, enabling flexible deployment and testing strategies.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>To understand the system:</p>
<ol>
<li>Review the <a href="./architecture/overview.html">System Overview</a> for architectural concepts</li>
<li>Examine <a href="./architecture/nodes.html">Node Types</a> for detailed component behavior</li>
<li>Study the <a href="./architecture/messages.html">Message Protocol</a> for interaction patterns</li>
<li>See <a href="./architecture/state-diagram.html">State Diagrams</a> for node state transitions</li>
</ol>
<p>For implementation details, consult the API Reference section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-architecture-overview"><a class="header" href="#system-architecture-overview">System Architecture Overview</a></h1>
<p>The MultiPaxos implementation follows a distributed architecture where consensus is achieved through coordinated interaction between three types of nodes. The system is designed with separation of concerns, where each node type has distinct responsibilities in the consensus process.</p>
<h2 id="architecture-principles"><a class="header" href="#architecture-principles">Architecture Principles</a></h2>
<p><strong>Sans-IO Design</strong>: Message processing logic is separated from network transport, enabling flexible deployment and comprehensive testing.</p>
<p><strong>State Machine Replication</strong>: All replicas maintain identical state by executing the same sequence of commands in the same order.</p>
<p><strong>Fault Tolerance</strong>: The system continues operating correctly despite node failures, provided sufficient nodes remain available.</p>
<p><strong>Configurable Deployment</strong>: Node roles, network topology, and timeout parameters are configurable for different deployment scenarios.</p>
<h2 id="system-components"><a class="header" href="#system-components">System Components</a></h2>
<h3 id="node-types"><a class="header" href="#node-types">Node Types</a></h3>
<p>The system consists of three distinct node types:</p>
<ul>
<li><strong>Replicas</strong>: Interface with clients and maintain application state</li>
<li><strong>Leaders</strong>: Coordinate consensus and manage proposal ordering</li>
<li><strong>Acceptors</strong>: Provide persistent storage for consensus decisions</li>
</ul>
<h3 id="communication-layer"><a class="header" href="#communication-layer">Communication Layer</a></h3>
<p>Nodes communicate through a message-passing system with the following characteristics:</p>
<ul>
<li>Asynchronous message delivery</li>
<li>Message queuing through mailbox abstraction</li>
<li>Configurable timeouts and retry mechanisms</li>
<li>Support for both reliable and unreliable network transports</li>
</ul>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<p>Each node maintains internal state appropriate to its role:</p>
<ul>
<li><strong>Slot-based ordering</strong> for command sequencing</li>
<li><strong>Ballot numbers</strong> for leader election and conflict resolution</li>
<li><strong>Promise tracking</strong> for consensus safety</li>
<li><strong>Configuration management</strong> for dynamic reconfiguration</li>
</ul>
<h2 id="consensus-flow"><a class="header" href="#consensus-flow">Consensus Flow</a></h2>
<p>The system achieves consensus through a two-phase protocol:</p>
<ol>
<li><strong>Phase 1 (Prepare)</strong>: Leaders request permission to propose values</li>
<li><strong>Phase 2 (Accept)</strong>: Leaders propose specific values for agreement</li>
</ol>
<p>This process ensures that only one value can be chosen for each position in the command sequence, maintaining consistency across all replicas.</p>
<h2 id="failure-handling"><a class="header" href="#failure-handling">Failure Handling</a></h2>
<p>The architecture addresses various failure scenarios:</p>
<ul>
<li><strong>Node failures</strong>: Remaining nodes continue operation</li>
<li><strong>Network partitions</strong>: Majority partitions can make progress</li>
<li><strong>Message loss</strong>: Timeout and retry mechanisms ensure delivery</li>
<li><strong>Leader failures</strong>: New leaders can be elected automatically</li>
</ul>
<h2 id="configuration-and-deployment"><a class="header" href="#configuration-and-deployment">Configuration and Deployment</a></h2>
<p>The system supports flexible deployment configurations:</p>
<ul>
<li>Variable numbers of each node type</li>
<li>Customizable network topologies</li>
<li>Adjustable timeout and retry parameters</li>
<li>Dynamic reconfiguration capabilities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-types-1"><a class="header" href="#node-types-1">Node Types</a></h1>
<p>As mentioned previously, there are three node types here:</p>
<ul>
<li>Replicas</li>
<li>Leaders</li>
<li>Acceptors</li>
</ul>
<p>Paxos is generally fault-tolerant in the face of <em>n</em> faults with <em>2n+1</em> Acceptors (and <em>n+1</em> Leaders and Replicas).</p>
<h2 id="replicas"><a class="header" href="#replicas">Replicas</a></h2>
<p>Replicas serve as the primary interface between clients and the consensus system while maintaining the replicated state machine.</p>
<h3 id="responsibilities"><a class="header" href="#responsibilities">Responsibilities</a></h3>
<p><strong>Client Interface</strong>: Replicas receive requests from clients and return responses after command execution.</p>
<p><strong>State Maintenance</strong>: Each replica maintains a copy of the application state and applies commands in the agreed sequence.</p>
<p><strong>Command Proposal</strong>: When receiving client requests, replicas propose commands to leaders for inclusion in the consensus sequence.</p>
<p><strong>Command Execution</strong>: Replicas execute commands in slot order, ensuring all replicas maintain identical state.</p>
<h3 id="key-state-variables"><a class="header" href="#key-state-variables">Key State Variables</a></h3>
<ul>
<li><code>slot_in</code>: Next slot number for new proposals</li>
<li><code>slot_out</code>: Next slot number for command execution</li>
<li><code>proposals</code>: Commands proposed but not yet decided</li>
<li><code>decisions</code>: Commands that have been decided by consensus</li>
<li><code>requests</code>: Client requests awaiting proposal</li>
</ul>
<h3 id="operation-flow"><a class="header" href="#operation-flow">Operation Flow</a></h3>
<ol>
<li>Receive client request</li>
<li>Add request to pending queue</li>
<li>Propose command to leaders for available slots</li>
<li>Wait for consensus decision</li>
<li>Execute command when slot becomes ready</li>
<li>Return response to client</li>
</ol>
<h2 id="leaders"><a class="header" href="#leaders">Leaders</a></h2>
<p>Leaders coordinate the consensus process by managing the two-phase Paxos protocol and handling leader election.</p>
<h3 id="responsibilities-1"><a class="header" href="#responsibilities-1">Responsibilities</a></h3>
<p><strong>Consensus Coordination</strong>: Leaders run the two-phase protocol (prepare/accept) to achieve agreement on command values.</p>
<p><strong>Proposal Management</strong>: Leaders receive proposals from replicas and coordinate their inclusion in the consensus sequence.</p>
<p><strong>Conflict Resolution</strong>: When multiple leaders compete, the system resolves conflicts through ballot number comparison.</p>
<p><strong>Decision Broadcasting</strong>: Once consensus is achieved, leaders broadcast decisions to all replicas.</p>
<h3 id="key-state-variables-1"><a class="header" href="#key-state-variables-1">Key State Variables</a></h3>
<ul>
<li><code>ballot_number</code>: Current ballot for this leader</li>
<li><code>proposals</code>: Commands being processed for consensus</li>
<li><code>p1b_responses</code>: Promise responses from acceptors</li>
<li><code>p2b_responses</code>: Accept responses from acceptors</li>
<li><code>active</code>: Whether this leader is currently active</li>
</ul>
<h3 id="operation-phases"><a class="header" href="#operation-phases">Operation Phases</a></h3>
<p><strong>Scout Phase</strong>: Leader attempts to become active by gathering promises from acceptors.</p>
<p><strong>Commander Phase</strong>: Active leader proposes specific values for slots and gathers acceptances.</p>
<p><strong>Decision Phase</strong>: Leader broadcasts decisions once sufficient acceptances are received.</p>
<h2 id="acceptors"><a class="header" href="#acceptors">Acceptors</a></h2>
<p>Acceptors provide the persistent storage layer for the consensus protocol, ensuring safety properties are maintained.</p>
<h3 id="responsibilities-2"><a class="header" href="#responsibilities-2">Responsibilities</a></h3>
<p><strong>Promise Management</strong>: Acceptors track ballot numbers and promise not to accept proposals from lower-numbered ballots.</p>
<p><strong>Proposal Storage</strong>: Acceptors store accepted proposals and their associated ballot numbers.</p>
<p><strong>Safety Enforcement</strong>: Acceptors ensure that only one value can be chosen for each slot by rejecting conflicting proposals.</p>
<p><strong>Persistence</strong>: Acceptors maintain durable storage of consensus state to survive failures.</p>
<h3 id="key-state-variables-2"><a class="header" href="#key-state-variables-2">Key State Variables</a></h3>
<ul>
<li><code>promised</code>: Highest ballot number promised for each slot</li>
<li><code>accepted</code>: Accepted proposals with their ballot numbers</li>
<li>Per-slot tracking of promises and acceptances</li>
</ul>
<h3 id="protocol-behavior"><a class="header" href="#protocol-behavior">Protocol Behavior</a></h3>
<p><strong>Phase 1a Response</strong>: When receiving prepare requests, acceptors either promise to ignore lower ballots or reject the request.</p>
<p><strong>Phase 2a Response</strong>: When receiving accept requests, acceptors either accept the proposal (if consistent with promises) or reject it.</p>
<h2 id="node-interaction-patterns"><a class="header" href="#node-interaction-patterns">Node Interaction Patterns</a></h2>
<h3 id="normal-operation"><a class="header" href="#normal-operation">Normal Operation</a></h3>
<ol>
<li>Client sends request to replica</li>
<li>Replica proposes command to leader</li>
<li>Leader runs two-phase protocol with acceptors</li>
<li>Leader broadcasts decision to replicas</li>
<li>Replicas execute command and respond to client</li>
</ol>
<h3 id="leader-election"><a class="header" href="#leader-election">Leader Election</a></h3>
<ol>
<li>Multiple leaders may attempt to become active</li>
<li>Leaders send prepare requests with unique ballot numbers</li>
<li>Higher-numbered ballots preempt lower-numbered ones</li>
<li>Only one leader becomes active for each ballot</li>
</ol>
<h3 id="failure-recovery"><a class="header" href="#failure-recovery">Failure Recovery</a></h3>
<ol>
<li>Failed nodes are detected through timeouts</li>
<li>Remaining nodes continue operation</li>
<li>New leaders can be elected if current leader fails</li>
<li>State is recovered from acceptor persistence</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-protocol"><a class="header" href="#message-protocol">Message Protocol</a></h1>
<p>The MultiPaxos implementation uses a structured message protocol to coordinate consensus between nodes. Understanding these messages is essential for comprehending system behavior and debugging distributed scenarios.</p>
<h2 id="message-types"><a class="header" href="#message-types">Message Types</a></h2>
<p>The protocol defines nine message types that facilitate the consensus algorithm and client interaction.</p>
<h3 id="consensus-protocol-messages"><a class="header" href="#consensus-protocol-messages">Consensus Protocol Messages</a></h3>
<h4 id="phase-1a-prepare"><a class="header" href="#phase-1a-prepare">Phase 1a (Prepare)</a></h4>
<p><strong>P1aMessage</strong>: Sent by leaders to acceptors to initiate ballot preparation.</p>
<ul>
<li><code>src</code>: Leader identifier</li>
<li><code>ballot_number</code>: Proposed ballot number for this round</li>
</ul>
<p>Leaders send P1a messages when attempting to become active or when starting a new consensus round.</p>
<h4 id="phase-1b-promise"><a class="header" href="#phase-1b-promise">Phase 1b (Promise)</a></h4>
<p><strong>P1bMessage</strong>: Sent by acceptors to leaders in response to P1a messages.</p>
<ul>
<li><code>src</code>: Acceptor identifier</li>
<li><code>ballot_number</code>: Ballot number being promised</li>
<li><code>accepted</code>: List of previously accepted proposals (PValue structs)</li>
</ul>
<p>Acceptors send P1b messages to promise they won't accept lower-numbered ballots and report any previously accepted proposals.</p>
<h4 id="phase-2a-accept"><a class="header" href="#phase-2a-accept">Phase 2a (Accept)</a></h4>
<p><strong>P2aMessage</strong>: Sent by leaders to acceptors to propose specific values.</p>
<ul>
<li><code>src</code>: Leader identifier</li>
<li><code>ballot_number</code>: Current ballot number</li>
<li><code>slot_number</code>: Slot for this proposal</li>
<li><code>command</code>: Command being proposed</li>
</ul>
<p>Leaders send P2a messages when proposing specific commands for consensus slots.</p>
<h4 id="phase-2b-accepted"><a class="header" href="#phase-2b-accepted">Phase 2b (Accepted)</a></h4>
<p><strong>P2bMessage</strong>: Sent by acceptors to leaders confirming proposal acceptance.</p>
<ul>
<li><code>src</code>: Acceptor identifier</li>
<li><code>ballot_number</code>: Ballot number of accepted proposal</li>
<li><code>slot_number</code>: Slot number of accepted proposal</li>
</ul>
<p>Acceptors send P2b messages to confirm they have accepted a specific proposal.</p>
<h3 id="control-messages"><a class="header" href="#control-messages">Control Messages</a></h3>
<h4 id="preempted"><a class="header" href="#preempted">Preempted</a></h4>
<p><strong>PreemptedMessage</strong>: Sent to notify leaders they have been preempted by higher ballots.</p>
<ul>
<li><code>src</code>: Sender identifier</li>
<li><code>ballot_number</code>: Higher ballot number that caused preemption</li>
</ul>
<p>This message informs leaders that a higher-numbered ballot is active, causing them to become inactive.</p>
<h4 id="adopted"><a class="header" href="#adopted">Adopted</a></h4>
<p><strong>AdoptedMessage</strong>: Sent to leaders when their ballot has been adopted.</p>
<ul>
<li><code>src</code>: Sender identifier</li>
<li><code>ballot_number</code>: Adopted ballot number</li>
<li><code>accepted</code>: List of accepted proposals from this ballot</li>
</ul>
<p>This message confirms that a leader's ballot is now active and provides any previously accepted proposals.</p>
<h4 id="decision"><a class="header" href="#decision">Decision</a></h4>
<p><strong>DecisionMessage</strong>: Sent by leaders to replicas announcing consensus decisions.</p>
<ul>
<li><code>src</code>: Leader identifier</li>
<li><code>slot_number</code>: Slot for which decision was made</li>
<li><code>command</code>: Command that was chosen for this slot</li>
</ul>
<p>Leaders broadcast decision messages once sufficient acceptors have accepted a proposal.</p>
<h3 id="client-interaction-messages"><a class="header" href="#client-interaction-messages">Client Interaction Messages</a></h3>
<h4 id="request"><a class="header" href="#request">Request</a></h4>
<p><strong>RequestMessage</strong>: Sent by clients to replicas requesting command execution.</p>
<ul>
<li><code>src</code>: Client identifier</li>
<li><code>command</code>: Command to be executed</li>
</ul>
<p>Clients use request messages to submit operations for execution by the replicated state machine.</p>
<h4 id="propose"><a class="header" href="#propose">Propose</a></h4>
<p><strong>ProposeMessage</strong>: Sent by replicas to leaders requesting command inclusion.</p>
<ul>
<li><code>src</code>: Replica identifier</li>
<li><code>slot_number</code>: Proposed slot for the command</li>
<li><code>command</code>: Command to be included in consensus</li>
</ul>
<p>Replicas send propose messages to request that leaders include specific commands in the consensus sequence.</p>
<h2 id="message-flow-patterns"><a class="header" href="#message-flow-patterns">Message Flow Patterns</a></h2>
<h3 id="normal-operation-flow"><a class="header" href="#normal-operation-flow">Normal Operation Flow</a></h3>
<pre><code>Client → Replica: Request(command)
Replica → Leader: Propose(slot, command)
Leader → Acceptors: P1a(ballot)
Acceptors → Leader: P1b(ballot, accepted_proposals)
Leader → Acceptors: P2a(ballot, slot, command)
Acceptors → Leader: P2b(ballot, slot)
Leader → Replicas: Decision(slot, command)
</code></pre>
<h3 id="leader-election-flow"><a class="header" href="#leader-election-flow">Leader Election Flow</a></h3>
<pre><code>Leader1 → Acceptors: P1a(ballot1)
Leader2 → Acceptors: P1a(ballot2)  // ballot2 &gt; ballot1
Acceptors → Leader1: Preempted(ballot2)
Acceptors → Leader2: P1b(ballot2, previous_accepted)
Leader2 → Acceptors: P2a(ballot2, slot, command)
</code></pre>
<h3 id="failure-recovery-flow"><a class="header" href="#failure-recovery-flow">Failure Recovery Flow</a></h3>
<pre><code>Replica → Leader: Propose(slot, command)
// Leader fails, timeout occurs
NewLeader → Acceptors: P1a(higher_ballot)
Acceptors → NewLeader: P1b(higher_ballot, accepted)
NewLeader → Acceptors: P2a(higher_ballot, slot, command)
</code></pre>
<h2 id="message-routing"><a class="header" href="#message-routing">Message Routing</a></h2>
<p>Messages are routed between nodes using address information maintained in the system configuration:</p>
<ul>
<li>Each node has a unique identifier and network address</li>
<li>Messages specify source and destination addresses</li>
<li>The transport layer handles actual message delivery</li>
<li>Message queues buffer incoming and outgoing messages</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The protocol handles various error conditions:</p>
<p><strong>Message Loss</strong>: Timeout mechanisms trigger retransmission of important messages.</p>
<p><strong>Out-of-Order Delivery</strong>: Ballot numbers and slot numbers provide ordering guarantees.</p>
<p><strong>Duplicate Messages</strong>: Idempotent message handling prevents state corruption.</p>
<p><strong>Network Partitions</strong>: Majority requirements ensure progress only when sufficient nodes are available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-diagrams"><a class="header" href="#state-diagrams">State Diagrams</a></h1>
<p>This section presents the state machines for each node type in the MultiPaxos implementation. Understanding these state transitions is crucial for comprehending node behavior and system dynamics.</p>
<h2 id="replica-state-machine"><a class="header" href="#replica-state-machine">Replica State Machine</a></h2>
<p>Replicas manage client requests and coordinate with leaders to maintain consistent state across the distributed system.</p>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Idle
    Idle --&gt; Proposing : receive_client_request()
    Proposing --&gt; WaitingDecision : send_propose_to_leaders()
    WaitingDecision --&gt; Executing : receive_decision()
    WaitingDecision --&gt; Reproposing : timeout / higher_ballot_preemption
    Executing --&gt; Idle : execute_command()
    Reproposing --&gt; WaitingDecision : retry_propose()
    Reproposing --&gt; Idle : give_up_after_max_retries()

    state Idle {
        [*] --&gt; ProcessingRequests
        ProcessingRequests --&gt; CheckingSlots
        CheckingSlots --&gt; ProcessingRequests
    }

    state Executing {
        [*] --&gt; ValidatingCommand
        ValidatingCommand --&gt; ApplyingCommand
        ApplyingCommand --&gt; SendingResponse
        SendingResponse --&gt; [*]
    }
</pre>
<h3 id="state-descriptions"><a class="header" href="#state-descriptions">State Descriptions</a></h3>
<p><strong>Idle</strong>: Replica is ready to accept new client requests and process incoming decisions.</p>
<p><strong>Proposing</strong>: Replica is preparing to send command proposals to leaders for available slots.</p>
<p><strong>WaitingDecision</strong>: Replica has sent proposals and is waiting for consensus decisions from leaders.</p>
<p><strong>Executing</strong>: Replica is applying decided commands to its state machine and preparing client responses.</p>
<p><strong>Reproposing</strong>: Replica is retrying failed proposals, typically due to leader preemption or timeout.</p>
<h3 id="key-transitions"><a class="header" href="#key-transitions">Key Transitions</a></h3>
<ul>
<li><strong>Client Request</strong>: Triggers transition from Idle to Proposing</li>
<li><strong>Proposal Sent</strong>: Moves from Proposing to WaitingDecision</li>
<li><strong>Decision Received</strong>: Advances from WaitingDecision to Executing</li>
<li><strong>Timeout/Preemption</strong>: Causes transition to Reproposing state</li>
<li><strong>Command Applied</strong>: Returns to Idle state for next request cycle</li>
</ul>
<h2 id="leader-state-machine"><a class="header" href="#leader-state-machine">Leader State Machine</a></h2>
<p>Leaders coordinate the consensus process through ballot management and two-phase protocol execution.</p>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Inactive
    Inactive --&gt; ScoutPhase : start_election()
    ScoutPhase --&gt; CommanderPhase : receive_adopted()
    ScoutPhase --&gt; Preempted : receive_preempted()
    CommanderPhase --&gt; Active : sufficient_acceptances()
    Active --&gt; CommanderPhase : new_proposal()
    Active --&gt; Preempted : higher_ballot_detected()
    Preempted --&gt; Inactive : backoff_complete()
    Inactive --&gt; ScoutPhase : retry_election()

    state ScoutPhase {
        [*] --&gt; SendingP1a
        SendingP1a --&gt; CollectingP1b
        CollectingP1b --&gt; EvaluatingPromises
        EvaluatingPromises --&gt; [*] : majority_achieved
        EvaluatingPromises --&gt; SendingP1a : insufficient_responses
    }

    state CommanderPhase {
        [*] --&gt; SendingP2a
        SendingP2a --&gt; CollectingP2b
        CollectingP2b --&gt; BroadcastingDecision
        BroadcastingDecision --&gt; [*]
    }

    state Active {
        [*] --&gt; MonitoringProposals
        MonitoringProposals --&gt; ProcessingProposal
        ProcessingProposal --&gt; MonitoringProposals
    }
</pre>
<h3 id="state-descriptions-1"><a class="header" href="#state-descriptions-1">State Descriptions</a></h3>
<p><strong>Inactive</strong>: Leader is not currently participating in consensus, waiting for election opportunity.</p>
<p><strong>ScoutPhase</strong>: Leader is attempting to become active by gathering promises from acceptors (Phase 1).</p>
<p><strong>CommanderPhase</strong>: Leader is proposing specific values and collecting acceptances (Phase 2).</p>
<p><strong>Active</strong>: Leader is successfully coordinating consensus and processing new proposals.</p>
<p><strong>Preempted</strong>: Leader has been superseded by a higher ballot and must become inactive.</p>
<h3 id="key-transitions-1"><a class="header" href="#key-transitions-1">Key Transitions</a></h3>
<ul>
<li><strong>Start Election</strong>: Inactive leader begins scout phase with new ballot</li>
<li><strong>Adopted</strong>: Scout phase succeeds, leader becomes active</li>
<li><strong>Preempted</strong>: Higher ballot detected, leader becomes inactive</li>
<li><strong>New Proposal</strong>: Active leader starts commander phase for new slot</li>
<li><strong>Backoff Complete</strong>: Preempted leader waits before retry</li>
</ul>
<h2 id="acceptor-state-machine"><a class="header" href="#acceptor-state-machine">Acceptor State Machine</a></h2>
<p>Acceptors maintain the persistent storage for consensus decisions and enforce protocol safety properties.</p>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Listening
    Listening --&gt; PromiseEvaluation : receive_p1a()
    PromiseEvaluation --&gt; PromiseGiven : ballot_acceptable()
    PromiseEvaluation --&gt; Listening : ballot_rejected()
    PromiseGiven --&gt; AcceptEvaluation : receive_p2a()
    PromiseGiven --&gt; Preempted : higher_ballot_p1a()
    AcceptEvaluation --&gt; ProposalAccepted : proposal_consistent()
    AcceptEvaluation --&gt; PromiseGiven : proposal_rejected()
    ProposalAccepted --&gt; Listening : send_p2b()
    Preempted --&gt; Listening : update_promise()

    state Listening {
        [*] --&gt; MonitoringMessages
        MonitoringMessages --&gt; PeriodicCleanup
        PeriodicCleanup --&gt; MonitoringMessages
    }

    state PromiseEvaluation {
        [*] --&gt; CheckingBallot
        CheckingBallot --&gt; ComparingPromises
        ComparingPromises --&gt; [*]
    }

    state AcceptEvaluation {
        [*] --&gt; ValidatingProposal
        ValidatingProposal --&gt; CheckingConsistency
        CheckingConsistency --&gt; [*]
    }

    state ProposalAccepted {
        [*] --&gt; StoringAcceptance
        StoringAcceptance --&gt; SendingResponse
        SendingResponse --&gt; [*]
    }
</pre>
<h3 id="state-descriptions-2"><a class="header" href="#state-descriptions-2">State Descriptions</a></h3>
<p><strong>Listening</strong>: Acceptor is ready to receive and process protocol messages from leaders.</p>
<p><strong>PromiseEvaluation</strong>: Acceptor is evaluating a P1a message to determine if it should make a promise.</p>
<p><strong>PromiseGiven</strong>: Acceptor has promised not to accept lower ballots and awaits P2a messages.</p>
<p><strong>AcceptEvaluation</strong>: Acceptor is evaluating a P2a message for consistency with previous promises.</p>
<p><strong>ProposalAccepted</strong>: Acceptor has accepted a proposal and is updating persistent state.</p>
<p><strong>Preempted</strong>: Acceptor has received a higher ballot and must update its promises.</p>
<h3 id="key-transitions-2"><a class="header" href="#key-transitions-2">Key Transitions</a></h3>
<ul>
<li><strong>P1a Received</strong>: Triggers evaluation of prepare request</li>
<li><strong>Promise Made</strong>: Acceptor commits to ignoring lower ballots</li>
<li><strong>P2a Received</strong>: Triggers evaluation of accept request</li>
<li><strong>Proposal Accepted</strong>: Acceptor stores the accepted value</li>
<li><strong>Higher Ballot</strong>: Causes preemption and promise update</li>
</ul>
<h2 id="cross-node-interaction-patterns"><a class="header" href="#cross-node-interaction-patterns">Cross-Node Interaction Patterns</a></h2>
<p>The state machines interact through message exchanges that drive state transitions across the distributed system:</p>
<p><strong>Client-Replica Interaction</strong>: Client requests trigger replica state changes from Idle to Proposing.</p>
<p><strong>Replica-Leader Coordination</strong>: Replica proposals cause leaders to enter Commander phase from Active state.</p>
<p><strong>Leader-Acceptor Protocol</strong>: Leader scout and commander phases drive acceptor state transitions through promise and accept evaluations.</p>
<p><strong>Failure Detection</strong>: Timeouts in any node can trigger state transitions that initiate recovery procedures.</p>
<p>These state machines operate concurrently across multiple nodes, with message passing providing the coordination mechanism that ensures consistent behavior throughout the distributed system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-diagrams"><a class="header" href="#sequence-diagrams">Sequence Diagrams</a></h1>
<p>This section illustrates the message flows and timing relationships between nodes during various operational scenarios. These diagrams help visualize the distributed coordination required for consensus.</p>
<h2 id="normal-operation-sequence"><a class="header" href="#normal-operation-sequence">Normal Operation Sequence</a></h2>
<p>The following diagram shows the complete flow from client request to response during normal system operation.</p>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant R as Replica
    participant L as Leader
    participant A1 as Acceptor1
    participant A2 as Acceptor2
    participant A3 as Acceptor3

    C-&gt;&gt;R: Request(command)
    Note over R: Add to requests queue
    R-&gt;&gt;L: Propose(slot_n, command)

    Note over L: Start consensus for slot_n
    L-&gt;&gt;A1: P1a(ballot_num)
    L-&gt;&gt;A2: P1a(ballot_num)
    L-&gt;&gt;A3: P1a(ballot_num)

    A1-&gt;&gt;L: P1b(ballot_num, accepted_vals)
    A2-&gt;&gt;L: P1b(ballot_num, accepted_vals)
    A3-&gt;&gt;L: P1b(ballot_num, accepted_vals)

    Note over L: Majority achieved, proceed to Phase 2
    L-&gt;&gt;A1: P2a(ballot_num, slot_n, command)
    L-&gt;&gt;A2: P2a(ballot_num, slot_n, command)
    L-&gt;&gt;A3: P2a(ballot_num, slot_n, command)

    A1-&gt;&gt;L: P2b(ballot_num, slot_n)
    A2-&gt;&gt;L: P2b(ballot_num, slot_n)
    Note over L: Majority acceptance achieved

    L-&gt;&gt;R: Decision(slot_n, command)
    Note over R: Execute command in slot order
    R-&gt;&gt;C: Response(result)
</pre>
<h3 id="key-points"><a class="header" href="#key-points">Key Points</a></h3>
<ul>
<li>Client request triggers the entire consensus process</li>
<li>Two-phase protocol ensures safety with majority agreement</li>
<li>Decision broadcast enables all replicas to execute the command</li>
<li>Response sent after command execution maintains consistency</li>
</ul>
<h2 id="leader-election-sequence"><a class="header" href="#leader-election-sequence">Leader Election Sequence</a></h2>
<p>This diagram shows how leadership conflicts are resolved when multiple leaders compete.</p>
<pre class="mermaid">sequenceDiagram
    participant L1 as Leader1
    participant L2 as Leader2
    participant A1 as Acceptor1
    participant A2 as Acceptor2
    participant A3 as Acceptor3

    Note over L1,L2: Both leaders attempt to become active

    L1-&gt;&gt;A1: P1a(ballot=1.1)
    L1-&gt;&gt;A2: P1a(ballot=1.1)
    L1-&gt;&gt;A3: P1a(ballot=1.1)

    L2-&gt;&gt;A1: P1a(ballot=2.2)
    L2-&gt;&gt;A2: P1a(ballot=2.2)
    L2-&gt;&gt;A3: P1a(ballot=2.2)

    Note over A1,A3: Higher ballot (2.2) takes precedence

    A1-&gt;&gt;L1: Preempted(ballot=2.2)
    A2-&gt;&gt;L1: Preempted(ballot=2.2)
    A3-&gt;&gt;L1: Preempted(ballot=2.2)

    A1-&gt;&gt;L2: P1b(ballot=2.2, previous_accepted)
    A2-&gt;&gt;L2: P1b(ballot=2.2, previous_accepted)
    A3-&gt;&gt;L2: P1b(ballot=2.2, previous_accepted)

    Note over L1: Becomes inactive, will retry later
    Note over L2: Becomes active, can proceed with proposals

    L2-&gt;&gt;A1: P2a(ballot=2.2, slot_n, command)
    L2-&gt;&gt;A2: P2a(ballot=2.2, slot_n, command)
    L2-&gt;&gt;A3: P2a(ballot=2.2, slot_n, command)
</pre>
<h3 id="key-points-1"><a class="header" href="#key-points-1">Key Points</a></h3>
<ul>
<li>Multiple leaders can attempt activation simultaneously</li>
<li>Higher ballot numbers take precedence (lexicographic ordering)</li>
<li>Preempted leaders become inactive and must retry with higher ballots</li>
<li>Only one leader becomes active per ballot round</li>
</ul>
<h2 id="failure-recovery-sequence"><a class="header" href="#failure-recovery-sequence">Failure Recovery Sequence</a></h2>
<p>This diagram illustrates how the system handles leader failure and recovery.</p>
<pre class="mermaid">sequenceDiagram
    participant R as Replica
    participant L1 as Leader1(Failed)
    participant L2 as Leader2(New)
    participant A1 as Acceptor1
    participant A2 as Acceptor2
    participant A3 as Acceptor3

    R-&gt;&gt;L1: Propose(slot_n, command)
    Note over L1: Leader fails before processing

    Note over R: Timeout waiting for decision
    Note over L2: Detects leader failure, starts election

    L2-&gt;&gt;A1: P1a(ballot=3.2)
    L2-&gt;&gt;A2: P1a(ballot=3.2)
    L2-&gt;&gt;A3: P1a(ballot=3.2)

    A1-&gt;&gt;L2: P1b(ballot=3.2, previous_accepted)
    A2-&gt;&gt;L2: P1b(ballot=3.2, previous_accepted)
    A3-&gt;&gt;L2: P1b(ballot=3.2, previous_accepted)

    Note over L2: Check previous accepted values
    Note over L2: Must propose previously accepted values first

    L2-&gt;&gt;A1: P2a(ballot=3.2, slot_k, prev_command)
    L2-&gt;&gt;A2: P2a(ballot=3.2, slot_k, prev_command)
    L2-&gt;&gt;A3: P2a(ballot=3.2, slot_k, prev_command)

    A1-&gt;&gt;L2: P2b(ballot=3.2, slot_k)
    A2-&gt;&gt;L2: P2b(ballot=3.2, slot_k)

    L2-&gt;&gt;R: Decision(slot_k, prev_command)

    Note over L2: Now can process new proposals
    Note over R: Retries original proposal
    R-&gt;&gt;L2: Propose(slot_n, command)

    L2-&gt;&gt;A1: P2a(ballot=3.2, slot_n, command)
    L2-&gt;&gt;A2: P2a(ballot=3.2, slot_n, command)
    L2-&gt;&gt;A3: P2a(ballot=3.2, slot_n, command)

    A1-&gt;&gt;L2: P2b(ballot=3.2, slot_n)
    A2-&gt;&gt;L2: P2b(ballot=3.2, slot_n)

    L2-&gt;&gt;R: Decision(slot_n, command)
</pre>
<h3 id="key-points-2"><a class="header" href="#key-points-2">Key Points</a></h3>
<ul>
<li>Failure detection occurs through timeouts</li>
<li>New leader must first complete any partially accepted proposals</li>
<li>Previously accepted values take priority over new proposals</li>
<li>System maintains consistency despite leader changes</li>
</ul>
<h2 id="network-partition-scenario"><a class="header" href="#network-partition-scenario">Network Partition Scenario</a></h2>
<p>This diagram shows behavior during a network partition where nodes are split into groups.</p>
<pre class="mermaid">sequenceDiagram
    participant R1 as Replica1
    participant L1 as Leader1
    participant A1 as Acceptor1
    participant A2 as Acceptor2
    participant A3 as Acceptor3
    participant L2 as Leader2
    participant R2 as Replica2

    Note over R1,A2: Majority partition (3 nodes)
    Note over A3,R2: Minority partition (2 nodes)

    R1-&gt;&gt;L1: Propose(slot_n, command1)
    R2-&gt;&gt;L2: Propose(slot_n, command2)

    Note over L1: Can reach majority of acceptors
    L1-&gt;&gt;A1: P1a(ballot=1.1)
    L1-&gt;&gt;A2: P1a(ballot=1.1)
    Note over L1,A3: Network partition - A3 unreachable

    Note over L2: Cannot reach majority of acceptors
    L2-&gt;&gt;A3: P1a(ballot=2.2)
    Note over A1,L2: Network partition - A1,A2 unreachable

    A1-&gt;&gt;L1: P1b(ballot=1.1, [])
    A2-&gt;&gt;L1: P1b(ballot=1.1, [])
    Note over L1: Majority achieved, proceed

    L1-&gt;&gt;A1: P2a(ballot=1.1, slot_n, command1)
    L1-&gt;&gt;A2: P2a(ballot=1.1, slot_n, command1)

    A1-&gt;&gt;L1: P2b(ballot=1.1, slot_n)
    A2-&gt;&gt;L1: P2b(ballot=1.1, slot_n)

    L1-&gt;&gt;R1: Decision(slot_n, command1)

    Note over A3,R2: Minority partition cannot make progress
    Note over L2: Waiting for majority, times out

    Note over R1,R2: Network partition heals
    Note over L2: Discovers higher ballot decisions
    L2-&gt;&gt;R2: Decision(slot_n, command1)
    Note over R2: Must apply majority decision
</pre>
<h3 id="key-points-3"><a class="header" href="#key-points-3">Key Points</a></h3>
<ul>
<li>Only partitions with acceptor majority can make progress</li>
<li>Minority partitions cannot achieve consensus and wait</li>
<li>When partition heals, minority adopts majority decisions</li>
<li>Consistency is maintained across partition boundaries</li>
</ul>
<h2 id="concurrent-proposals-sequence"><a class="header" href="#concurrent-proposals-sequence">Concurrent Proposals Sequence</a></h2>
<p>This diagram shows how multiple concurrent proposals are handled across different slots.</p>
<pre class="mermaid">sequenceDiagram
    participant R1 as Replica1
    participant R2 as Replica2
    participant L as Leader
    participant A1 as Acceptor1
    participant A2 as Acceptor2
    participant A3 as Acceptor3

    Note over R1,R2: Multiple replicas propose simultaneously

    R1-&gt;&gt;L: Propose(slot_5, command_A)
    R2-&gt;&gt;L: Propose(slot_6, command_B)

    Note over L: Process both proposals concurrently

    par Slot 5 Processing
        L-&gt;&gt;A1: P2a(ballot=1.1, slot_5, command_A)
        L-&gt;&gt;A2: P2a(ballot=1.1, slot_5, command_A)
        L-&gt;&gt;A3: P2a(ballot=1.1, slot_5, command_A)
    and Slot 6 Processing
        L-&gt;&gt;A1: P2a(ballot=1.1, slot_6, command_B)
        L-&gt;&gt;A2: P2a(ballot=1.1, slot_6, command_B)
        L-&gt;&gt;A3: P2a(ballot=1.1, slot_6, command_B)
    end

    par Slot 5 Responses
        A1-&gt;&gt;L: P2b(ballot=1.1, slot_5)
        A2-&gt;&gt;L: P2b(ballot=1.1, slot_5)
    and Slot 6 Responses
        A1-&gt;&gt;L: P2b(ballot=1.1, slot_6)
        A3-&gt;&gt;L: P2b(ballot=1.1, slot_6)
    end

    Note over L: Both slots achieve majority

    par Decision Broadcast
        L-&gt;&gt;R1: Decision(slot_5, command_A)
        L-&gt;&gt;R2: Decision(slot_5, command_A)
    and
        L-&gt;&gt;R1: Decision(slot_6, command_B)
        L-&gt;&gt;R2: Decision(slot_6, command_B)
    end

    Note over R1,R2: Execute commands in slot order
</pre>
<h3 id="key-points-4"><a class="header" href="#key-points-4">Key Points</a></h3>
<ul>
<li>Multiple slots can be processed concurrently</li>
<li>Each slot requires independent majority agreement</li>
<li>Commands are executed in slot order regardless of decision timing</li>
<li>Parallelization improves system throughput</li>
</ul>
<p>These sequence diagrams demonstrate the sophisticated coordination required for distributed consensus while highlighting the system's ability to handle various operational scenarios and failure conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replica"><a class="header" href="#replica">Replica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leader"><a class="header" href="#leader">Leader</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acceptor"><a class="header" href="#acceptor">Acceptor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
